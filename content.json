{"posts":[{"title":"FFmpeg compile for android","text":"字节流动：FFmpeg 编译和集成 编译环境 wsl2-ubuntu android-ndk-r20b-linux-x86_64 ffmpeg-4.2.2 FFmpeg 代码下载 &amp; 编译配置12wget https://ffmpeg.org/releases/ffmpeg-4.2.2.tar.bz2./configure --disable-x86asm 编译脚本arm64-v8a 1vim build_android_arm64-v8a_clang.sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/bin/bashexport NDK=/home/dushicai/bin/ndk/android-ndk-r20bTOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64function build_android{./configure \\--prefix=$PREFIX \\--enable-neon \\--enable-hwaccels \\--enable-gpl \\--disable-postproc \\--disable-debug \\--enable-small \\--enable-jni \\--enable-mediacodec \\--enable-decoder=h264_mediacodec \\--enable-static \\--enable-shared \\--disable-doc \\--enable-ffmpeg \\--disable-ffplay \\--disable-ffprobe \\--disable-avdevice \\--disable-doc \\--disable-symver \\--cross-prefix=$CROSS_PREFIX \\--target-os=android \\--arch=$ARCH \\--cpu=$CPU \\--cc=$CC \\--cxx=$CXX \\--enable-cross-compile \\--sysroot=$SYSROOT \\--extra-cflags=&quot;-Os -fpic $OPTIMIZE_CFLAGS&quot; \\--extra-ldflags=&quot;$ADDI_LDFLAGS&quot;make cleanmake -j16make installecho &quot;============================ build android arm64-v8a success ==========================&quot;}#arm64-v8aARCH=arm64CPU=armv8-aAPI=21CC=$TOOLCHAIN/bin/aarch64-linux-android$API-clangCXX=$TOOLCHAIN/bin/aarch64-linux-android$API-clang++SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysrootCROSS_PREFIX=$TOOLCHAIN/bin/aarch64-linux-android-PREFIX=$(pwd)/android/$CPUOPTIMIZE_CFLAGS=&quot;-march=$CPU&quot; armv7-a 12345678910#armv7-aARCH=armCPU=armv7-aAPI=21CC=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clangCXX=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clang++SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysrootCROSS_PREFIX=$TOOLCHAIN/bin/arm-linux-androideabi-PREFIX=$(pwd)/android/$CPUOPTIMIZE_CFLAGS=&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU &quot; 修改脚本权限1chmod +x build_android_arm64-v8a_clang.sh 运行脚本1./build_android_arm64-v8a_clang.sh","link":"/2022/08/27/FFmpeg-compile-for-android/"},{"title":"ffmpeg4.1 compile on wsl2","text":"Compile FFmpeg for Ubuntu, Debian, or Mintdoxygen/4.1 1PATH=&quot;$HOME/bin:$PATH&quot; PKG_CONFIG_PATH=&quot;$HOME/ffmpeg_build/lib/pkgconfig&quot; 1234567891011121314151617181920212223./configure \\ --prefix=&quot;$HOME/ffmpeg_build&quot; \\ --pkg-config-flags=&quot;--static&quot; \\ --extra-cflags=&quot;-I$HOME/ffmpeg_build/include&quot; \\ --extra-ldflags=&quot;-L$HOME/ffmpeg_build/lib&quot; \\ --extra-libs=&quot;-lpthread -lm&quot; \\ --ld=&quot;g++&quot; \\ --bindir=&quot;$HOME/bin&quot; \\ --enable-gpl \\ --enable-gnutls \\ --enable-libass \\ --enable-libfdk-aac \\ --enable-libfreetype \\ --enable-libmp3lame \\ --enable-libopus \\ --enable-libvorbis \\ --enable-libvpx \\ --enable-libx264 \\ --enable-libx265 \\ --enable-nonfree &amp;&amp; \\PATH=&quot;$HOME/bin:$PATH&quot; make &amp;&amp; \\make install &amp;&amp; \\hash -r 1export PKG_CONFIG_PATH=/home/dushicai/ffmpeg_build/lib/pkgconfig:PKG_CONFIG_PATH 1gcc -g -o main ./src/main.c -Iinclude `pkg-config --libs libavformat libavutil`","link":"/2022/04/10/FFmpeg-compile-on-wsl2/"},{"title":"adb","text":"挂载mount -o rw,remount /product 打印运行奔溃logcat -s DEBUG AndroidRuntime 关闭LinuxSEsetenforce 0echo 0 &gt; /proc/sys/kernel/printk 打印指定pid日志logcat –pid 222 关闭LinuxSEsetenforce 0echo 0 &gt; /proc/sys/kernel/printk pidadb shell ps | findstr zygoteadb shell ps | findstr pid 系统属性设置setprop vendor.tv.xxx.enable truegetprop | grep vendor.tv.xxx.enable 版本号adb shell pm dump com.droidlogic.android.tv | findstr version 查看现有输入系统adb shell dumpsys input 输入事件adb shell getevent 截屏模拟 dumpsys windowdumpsys window geteventgetevent 配置网卡macifconfig eth0 downifconfig eth0 hw ether 02:ad:38:01:42:13ifconfig eth0 up 引用孔小乐：Android dumpsys 常用命令","link":"/2023/05/12/adb/"},{"title":"cmakelist编写小记","text":"CV随手小记：Cmakelist 编写小记 Cmake全称Cross Platform Make，起初为了跨平台需求，而后不断完善并广泛使用。优势是跨平台， 支持Linux, Mac和Windows等不同操作系统。 一.Cmake与其他编译工具的对比gcc/g++是很常见的编译工具，是由GNU开发的编程语言译器， 主要用于C/C++等语言的开发，当项目简单，可以用gcc/g++编译目标和项目，但比较复杂时， 只用gcc组织编译架构会变得极其困难。Makefile是有条理的gcc编译命令的文件，利用make工具来执行Makefile文件的编译指令，当程序简单时， 可以手写Makefile，当程序复杂时， 一般利用CMake来自动生成Makefile。因而Cmake类似Make工具功能，用来“读取”并执行CMakeLists.txt文件的语句， 最终生成Makefile文件。Cmake语言开发相对简单，易于理解。 二.Cmake的常用指令Cmake类似Make工具功能，用来读取并执行CMakeLists.txt，这个文件是cmake的构建定义文件，文件名是大小写相关的，如果工程存在多个目录，需要确保每个要管理的目录都存在一个CMakeLists.txt。CMakeLists.txt有一些的常用指令，笔者总结了自己项目过程里最常用的指令，不常用的没有列出。主要${}是引用变量，这是cmake的变量应用方式，但是，有一些例外，比如在IF控制语句，变量是直接使用变量名引用，而不需要${}。如果使用了${}去应用变量，其实IF会去判断名为${}所代表的值的变量，那当然是不存在的了。 project(projectname [CXX] [C] [Java]) 用这个指令定义工程名称，并可指定工程支持的语言，支持的语言列表是可以忽略的。 set( ) set指令可以用来显式的定义变量。 message([SEND_ERROR | STATUS | FATAL_ERROR] “message to display”…) 这个指令用于向终端输出用户定义的信息，包含了三种类型: SEND_ERROR，产生错误，生成过程被跳过。 SATUS，输出前缀为– 的信息（以简洁的方式显示用户感兴趣的信息）。 FATAL_ERROR，立即终止所有cmake过程。 如message(STATUS “PROJECT_NAME: “ ${PROJECT_NAME})最终能看到– PROJECT_NAME: demo这样的提示信息。 也可以直接这样：message(“OpenCV: ${OpenCV_LIBS}”)就直接显示信息。 find_package( [version] [EXACT] [QUIET] [MODULE] [REQUIRED [[COMPONENTS] [components…]] [OPTIONAL_COMPONENTS components…]) 主要是寻找和加载外部项目。如果PackageName找到了，PackageName-found会显出，当没有找到时，默认显示PackageName-not found。通过模式的选择，可以处理在没有找到包时的解决方案。QUIET：不显示有用信息，REQUIRED：报错。 如找oepncv库可以这样用：find_package(OpenCV REQUIRED) find_path ( name0|NAMES name1 [path1 path2 …]) 用以寻找包含着name1文件的目录，如果找到了结果存储在VAR，没有找到结果结果是VAR-not found。成功时，变量被清除find_path再次搜索，没有成功,fin_path再次以相同的变量被调用时搜索。 add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 这个指令用于向当前工程添加将被编译的存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。指明CMakeLists.txt所在目录下包含了一个子目录source_dir，这样source_dir下的源文件和CMakeLists.txt等也会被处理。EXCLUDE_FROM_ALL参数的含义是将这个目录从编译过程中排除，比如，工程的example，可能就需要工程构建完成后，再进入example目录单独进行构建。 INSTALL 用于定义安装规则，安装的内容可以包括目标二进制、动态库、静态库以及文件、目录、脚本等。 常用的如OpenCV一般情况下安装到系统目录，即/usr/lib, /usr/bin和/usr/include [Ubuntu系统] 三.与静态库和共享库相关的指令静态库：链接阶段， 库中目标文件所含的所有将被程序使用的函数的机器码， 被copy到最终的可执行文件中，因此对应的链接方式称为静态链接。静态库对函数库的链接是放在编译时期完成的，程序在运行时与函数库再无瓜葛， 移植方便，所以运行效率相对快，但缺点是占用磁盘和内存空间，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。 动态库（共享库）：程序编译时并不会被连接到目标代码中， 而是在程序运行时才被载入。所以静态库是牺牲了空间效率， 换取了时间效率；共享库是牺牲了时间效率， 换取了空间效率； 静态库、 动态库的区别来自【链接阶段】如何处理库， 链接成可执行的程序。 首先看看如何建立静态库和共享库。 add_library (name dir) 用在目录dir下的源文件生成一个名为name的静态链接库：libname.a （win下是产生name.lib）注意会自动在名字前加lib。 add_library(libname SHARED source1 source2 … sourceN) 生成一个名为name的动态库(扩展名为.so，win下是.dll) 接下来看看如何使用外部共享库和头文件。 add_executable(hello ${SRC_LIST}) 定义了这个工程会生成一个文件名为hello的可执行文件，相关的源文件是SRC_LIST中定义的源文件列表， 例如add_executable(hello main.cpp)。一般都要包含main.hpp头文件。 target_link_libraries(exec library1&lt;debug | optimized&gt; library2…) 表示为可执行程序exec添加需要链接的静态库或共享库。如TARGET_LINK_LIBRARIES(main libhello.so)再如TARGET_LINK_LIBRARIES(main libhello.a)。 include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …) 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，默认的行为是追加到当前的头文件搜索路径的后面。 target_include_directories([SYSTEM][BEFORE]&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items]) 设置include文件查找的目录，具体包含头文件应用形式，安装位置等。 ADD_CUSTOM_COMMAND/TARGET [COMMAND] : 为工程添加一条自定义的构建规则。[TARGET] : 用于给指定名称的目标执行指定的命令，该目标没有输出文件，并始终被构建。 如在cmakelist.txt里写如下函数就自定义了一个copy共享库的自定义命令。 123456789function(cpy_dlls_to_target targe) foreach (DFILE ${ARGN}) message(&quot;dll: &quot; ${DFILE}) add_custom_command(TARGET ${targe} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different &quot;${DFILE}&quot; $&lt;TARGET_FILE_DIR:${targe}&gt;) endforeach ()endfunction() 四.简单的案例生成的库文件和可执行文件可以放在不同的文件夹下面，方便管理： #把生成的全部的dll和exe输出到某个文件夹下 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) #把生成的全部的lib文件输出到某个文件夹下 set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib) 抓取某个文件夹下面的全部cpp文件可以这样： #抓取全部的cpp文件 file(GLOB SOURCES ${PROJECT_SOURCE_DIR}/Xxxx/*.cpp) 这里举以调opencv库来实现自己的程序main.cpp为例串联下常用指令。那么项目目录下CMakeLists.txt这样写。 123456789101112cmake_minimum_required(VERSION 3.6)set(PROJECT_NAME &quot;demo&quot;)project(${PROJECT_NAME})set(CMAKE_CXX_STANDARD 11)set(OpenCV_INCLUDE_DIR &quot;D:/opencv3.3/opencv/build/include/&quot;)set(OpenCV_LIBS &quot;D:/opencv3.3/opencv/build/x64/vc14/lib/opencv_world330d.lib&quot;)set(OpenCV_DLL &quot;D:/opencv3.3/opencv/build/x64/vc14/bin/opencv_world330d.dll&quot;)add_executable(${PROJECT_NAME} main.cpp)# 链接OpenCV库文件target_include_directories(${PROJECT_NAME} PUBLIC ${OpenCV_INCLUDE_DIR})target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS}) 当然假如说自己写的源代码太多，就不能都以add_executable(${PROJECT_NAME} main.cpp xxx.cpp)这样的方式了，而是应该把自己实现的某些程序当成库。这里假设自己实现的库名字叫myfunctions，创了一个名为myfunctions的文件夹，此时有好几个用于实现某种想要功能的源代码在这个文件夹下，我们可以在myfunctions下也写一个CMakeLists.txt， 生成一个自建的库：add_library(myfunctions xxx.cpp xxxx.cpp) 当然自建库相当于就是开发一个sdk，自然可以使用外部的库如opencv等库，CMakeLists.txt可以写很多功能。完成了自建库后，在项目目录下的CMakeLists.txt里调用自建库。 经过修改，再加一个自动复制opencv的dll到clion创建项目的所需目录下（因为如果使用clion开发，必须要有dll文件在文件夹cmake-build-release或cmake-build-debug下）。假如自己的项目有一个文件夹叫src，存放了许多自己的项目代码，那么就需要aux_source_directory(./src DIR_my)，然后add_executable(${PROJECT_NAME} ${DIR_SRCS})。完善的项目目录下的CMakeLists.txt这么写： 123456789101112131415161718192021222324252627282930313233343536373839404142cmake_minimum_required(VERSION 3.6)set(PROJECT_NAME &quot;demo&quot;)project(${PROJECT_NAME})MESSAGE(STATUS &quot;PROJECT_NAME: &quot; ${PROJECT_NAME})set(CMAKE_CXX_STANDARD 11)# Check platformsif (CMAKE_HOST_WIN32) set(WINDOWS 1) MESSAGE(STATUS &quot;PLATFORM: WINDOWS&quot;)elseif (CMAKE_HOST_APPLE) set(MACOS 1) MESSAGE(STATUS &quot;PLATFORM: MACOS&quot;)elseif (CMAKE_HOST_UNIX) set(LINUX 1) MESSAGE(STATUS &quot;PLATFORM: LINUX&quot;)endif ()set(OpenCV_INCLUDE_DIR &quot;D:/opencv3.3/opencv/build/include/&quot;)set(OpenCV_LIBS &quot;D:/opencv3.3/opencv/build/x64/vc14/lib/opencv_world330d.lib&quot;)set(OpenCV_DLL &quot;D:/opencv3.3/opencv/build/x64/vc14/bin/opencv_world330d.dll&quot;)function(cpy_dlls_to_target targe) foreach (DFILE ${ARGN}) message(&quot;dll: &quot; ${DFILE}) add_custom_command(TARGET ${targe} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different &quot;${DFILE}&quot; $&lt;TARGET_FILE_DIR:${targe}&gt;) endforeach ()endfunction()aux_source_directory(./src DIR_my)include_directories (&quot;${PROJECT_SOURCE_DIR}/myfunctions&quot;)add_subdirectory (myfunctions)set (EXTRA_LIBS ${EXTRA_LIBS} myfunctions)if (WINDOWS) cpy_dlls_to_target(${PROJECT_NAME} &quot;${OpenCV_DLL}&quot;)endif (WINDOWS)add_executable(${PROJECT_NAME} ${DIR_SRCS})# 链接库文件target_include_directories(${PROJECT_NAME} PUBLIC ${OpenCV_INCLUDE_DIR})target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS} ${EXTRA_LIBS}) 自动复制也可以这么写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different ${REQUIRED_DLL} $&lt;TARGET_FILE_DIR:${PROJECT_NAME}&gt;)再放一个例子：cmake_minimum_required(VERSION 3.15)set(PROJECT_NAME &quot;undistort&quot;)project(${PROJECT_NAME})set(CMAKE_BUILD_TYPE &quot;Release&quot;)set(CMAKE_CXX_STANDARD 14)#把生成的全部的dll和exe输出到某个文件夹下set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)#把生成的全部的lib文件输出到某个文件夹下set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)# OpenMPFIND_PACKAGE(OpenMP)IF(OPENMP_FOUND) OPTION(WITH_OPENMP &quot;Whether to use parallel processing capabilities of OPENMP. ON/OFF&quot; ON)ENDIF(OPENMP_FOUND)IF(OPENMP_FOUND AND WITH_OPENMP) MESSAGE(STATUS &quot;With OpenMP &quot;) SET (CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -DMAX_OPENMP_NUM_THREADS=${PROCESSOR_COUNT} -DOPENMP_NUM_THREADS=${PROCESSOR_COUNT} ${OpenMP_CXX_FLAGS} -DOPENMP&quot;) SET(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -DMAX_OPENMP_NUM_THREADS=${PROCESSOR_COUNT} -DOPENMP_NUM_THREADS=${PROCESSOR_COUNT} ${OpenMP_CXX_FLAGS} ${OpenMP_C_FLAGS} -DOPENMP&quot;)ELSE(OPENMP_FOUND AND WITH_OPENMP) MESSAGE(STATUS &quot;Without OpenMP&quot;) SET (CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -DMAX_OPENMP_NUM_THREADS=1 -DOPENMP_NUM_THREADS=1&quot;) SET (CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -DMAX_OPENMP_NUM_THREADS=1 -DOPENMP_NUM_THREADS=1&quot;)ENDIF(OPENMP_FOUND AND WITH_OPENMP)#头文件载入include_directories( &quot;${PROJECT_SOURCE_DIR}/libpng1637_x64/include&quot; &quot;D:/opencv/opencv3.4.5/opencv/build/include&quot;)#lib库的载入link_directories( &quot;D:/opencv/opencv3.4.5/opencv/build/x64/vc15/lib&quot; &quot;${PROJECT_SOURCE_DIR}/libpng1637_x64/library&quot;)#抓取全部的cpp文件file(GLOB SOURCES ${PROJECT_SOURCE_DIR}/ldm_pq2p_io/*.cpp)#生成可执行文件add_executable(${PROJECT_NAME} ${SOURCES})#链接lib静态库target_link_libraries(${PROJECT_NAME} opencv_world345 libpng16 zlib)#载入必要的dll库list(APPEND REQUIRED_DLL &quot;D:/opencv/opencv3.4.5/opencv/build/x64/vc15/bin/opencv_world345.dll&quot;)list(APPEND REQUIRED_DLL &quot;${PROJECT_SOURCE_DIR}/libpng1637_x64/library/libpng16.dll&quot;)#将dll复制进去add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different ${REQUIRED_DLL} $&lt;TARGET_FILE_DIR:${PROJECT_NAME}&gt;) 注意事项： 在linux下编译cmakelist，只需要工程目录下新建build目录，然后cmake ..，再make就行了（当然make -j8是多线程make），但注意相比windows，linux下编译需要加如下行： set(CMAKE_C_FLAGS “${CMAKE_C_FLAGS} -O3”)set(CMAKE_CXX_FLAGS “${CMAKE_CXX_FLAGS} -O3”)set(CMAKE_POSITION_INDEPENDENT_CODE ON) 前两行是编译选项，当然如果用编译器编译，就不用加这两行，否则不加这两行速度会变慢，第三行是为了与位置无关！否则别人调用你的sdk就会报错啦（windows不用，因为是手动copy dll文件的）","link":"/2022/08/28/cmakelist%E7%BC%96%E5%86%99%E5%B0%8F%E8%AE%B0/"},{"title":"compile ijkplayer","text":"bilibili/ijkplayerffmepg4出现编译错误libavcodec/hevc_mvs.c","link":"/2022/11/19/compile-ijkplayer/"},{"title":"gcc","text":"123gcc -g -o -O2 main main.c -I.. -L.. -lgcc -g -o main main.c -Iinclude -Llib -lavutilgcc -g -o main ./src/main.c &quot;pkg-config --libs libavformat libavutil&quot; -g编译带调试信息-o输出文件-O2编译O2优化，默认O1完成的调试信息-I(可多个)指定头文件-L指定库文件地址-l指定使用的库 预编译头文件与源码合并编译正式编译链接：静态/动态程序与需要的库文件链接到一起 1libtool -static -o libmylib.a main.o","link":"/2022/04/10/gcc/"},{"title":"git","text":"配置用户名 1git config --global user.name git 配置邮箱 1git config --global user.email git@git.com 修改git编辑器为vim 1git config --global core.editor vim 1git config --global core.editor vim 查看分支 1git branch -a -av -vv 清理 1git clean -df -f/–force：强制删除-d：递归目录-n/dry-run：不删除，只显示要删除什么修改文件 1git mv aaa.md bbb.md 删除追踪 1git rm aaa.md 查看远程地址 1git remote -v 添加远程地址 1git add origin https://github.com/dushicai/dushicai.github.io.git 删除远程地址 1git remove origin 状态 1git status -s -b -s/–short：短格式-b/–branch：分支信息迁出分支 1git checkout -b xxx xxx 显示.git位置 1git rev-parse --git-dir 显示根目录位置 1git rev-parse --show-toplevel 显示相对路劲 1git rev-parse --show-prefix 显示当前目录cd深度 1git rev-parse --show-cdup 存储当前改动 1git stash 提交 1git commit 追加提交 1git commit --amend","link":"/2023/05/15/git/"},{"title":"grep","text":"-n显示匹配行号-v反选-c总数统计^头部匹配$尾部匹配","link":"/2023/05/12/grep/"},{"title":"hexo config","text":"1npm install hexo-cli -g 1hexo init blog 1cd blog 1npm install 1hexo server 无法加载文件 C:\\Users\\xxx\\AppData\\Roaming\\npm\\hexo.ps1，因为在此系统上禁止运行脚本 powershell(管理员权限) 1set-ExecutionPolicy RemoteSigned Y","link":"/2022/04/10/hexo-config/"},{"title":"logcat","text":"猫咪不吃鱼:Android 日志系统分析 一、前言logcat 作为读取日志的工具，相当于client 的角色；在前两篇文章中，关于 logcat 如何与其他部分沟通获取日志信息的流程已经介绍的比较清晰，本文不在赘述，转而归纳一下 logcat 的一些常用指令，并对其中一些做详细分析 二、命令简介 选项 描述 eg -s 输出指定 tag 的日志，相当于过滤器表达式 ‘*:S’ logcat -s tag -f 设置logcat 内容保存的位置，默认是stdout logcat -f sdcard/log.txt -r 每输出 时轮替日志文件，默认是16 必须配合 -f (暂不明白) logcat -f sdcard/log.txt -r 1 -n 设置日志输出的最大数目, 需要 -r 参数 暂不明白 -v 设置日志消息的输出格式。详见下文 格式化输出 logcat -v thread -D 输出各个日志缓冲区之间的分隔线 logcat -D … -c 清除（清空）所选的缓冲区并退出，默认清除 main、system 和 crash logcat -c / -b all -c -d 将日志转储到屏幕并退出 logcat -d &gt; log.txt -e 输出正则匹配的日志消息 logcat -e 匹配数据 -m 5 -m 输出 行后退出 …… -t 仅输出最新的行数，此选项包括 -d 功能 logcat -t 5 -t ‘‘ 输出自指定时间以来的最新行，此选项包括 -d 功能 logcat -t ‘01-26 20:52:41.820’ -g 获取指定日志缓冲区的大小并退出 logcat -g -G 设置日志环形缓冲区的大小，可以在结尾处添加 K 或 M logcat -G 2M -b 加载可供查看的日志缓冲区，更多可见下文 日志缓冲区 logcat -b system -B 以二进制文件形式输出日志 …… -S 在输出中包含统计信息，以识别和定位日志垃圾信息发送者 …… –pid= 仅输出来自给定 PID 的日志 logcat –pid=4355 三、日志缓冲区Android 日志系统为日志消息保留了多个环形缓冲区，但并非多有的日志消息都会发送到默认的环形缓冲区。这里可以采用 logcat -b 命令查看设备的其他缓冲区： 缓冲区 描述 eg radio 输出通信系统的日志，包含无线装置/电话相关消息 logcat -b radio events 输出event模块的日志 logcat -b events main 主日志缓冲区(默认)，不包含系统和崩溃日志消息 logcat -b main system 输出系统日志 logcat -b system crash 输出崩溃日志 logcat -b crash all 输出所有缓冲区日志 logcat -b all default 输出main、system、crash缓冲区日志 logcat -b default 如果需要查看内核空间日志信息，可采用如下几种方式查看： 1、读取 /proc/kmsg ，命令如下 1adb shell cat /proc/kmsg 读取/proc/kmsg属于消费型读取，读取之后再次读取不会显示已经读取过的日志信息 2、读取 /dev/kmsg，命令如下 1adb shell cat /dev/kmsg 读取/dev/kmsg会显示缓存区里面的所有日志信息。新写入的日志信息会不断累加到日志缓冲器中 3、使用 dmesg 命令读取 1adb shell dmesg dmesg命令读取一次只显示一部分日志,非阻塞执行 四、格式化输出使用 -v 命令来修改 log 的输出格式，以显示特定的元数据字段： 格式 描述 eg brief 显示优先级、标记以及发出消息的进程的 PID …… long 显示所有元数据字段，并使用空白行分隔消息 …… process 仅显示 PID …… raw 显示不包含其他元数据字段的原始日志消息 …… tag 仅显示优先级和标记 …… thread 旧版格式，显示优先级、PID 以及发出消息的线程的 TID …… threadtime （默认值）显示日期、调用时间、优先级、标记、PID 以及发出消息的线程的 TID …… time 显示日期、调用时间、优先级、标记以及发出消息的进程的 PID …… color 使用不同的颜色来显示每个优先级 …… descriptive 显示日志缓冲区事件说明。此修饰符仅影响事件日志缓冲区消息，不会对其他非二进制文件缓冲区产生任何影响 …… epoch 显示自 1970 年 1 月 1 日以来的时间（以秒为单位） …… monotonic 显示自上次启动以来的时间（以 CPU 秒为单位） …… printable 确保所有二进制日志记录内容都进行了转义 …… uid 如果访问控制允许，则显示 UID 或记录的进程的 Android ID …… usec 显示精确到微秒的时间 …… UTC 显示 UTC 时间 …… year 将年份添加到显示的时间 …… zone 将本地时区添加到显示的时间 …… 优先级： 选项 描述 eg V –Verbose(最低优先级) adb logcat *:v D – Debug adb logcat *:d I – Info adb logcat *:i W – Warning adb logcat *:w E – Error adb logcat *:e F – Fatal adb logcat *:f S – Silent adb logcat *:s 五、logcat -f 命令详解logcat -f 命令可以将日志消息输出到指定的文件中。这里我们需要确定的一件事是 logcat 作为客户端的角色，会将通过 liblog 获得的日志信息进行格式解析、格式化处理，而 liblog 库本身并不存在保存、解析的功能。这里来对 -f 指令做一下解析： 123456789101112131415161718192021222324252627282930313233logcat_main.cpp # main() ---&gt; logcat.cpp # android_logcat_run_command() ---&gt; __logcat() { ...... case 'f': if ((tail_time == log_time::EPOCH) &amp;&amp; !tail_lines) { tail_time = lastLogTime(optctx.optarg); } // redirect output to a file context-&gt;outputFileName = optctx.optarg; //注释 ① break; ...... setupOutputAndSchedulingPolicy() //注释 ② while (...) { //注释 ③ int ret = android_logger_list_read(logger_list, &amp;log_msg); if (context-&gt;printBinary) { printBinary(context, &amp;log_msg); } else { processBuffer(context, dev, &amp;log_msg); } ...... } 5.1 注释① ：解析 -f 指令1234567case 'f': if ((tail_time == log_time::EPOCH) &amp;&amp; !tail_lines) { tail_time = lastLogTime(optctx.optarg); } // redirect output to a file context-&gt;outputFileName = optctx.optarg; //注释 ① break; 在 _logcat() 函数中解析 -f 指令，设置日志输出文件。例如 logcat -f sdcard/log.txt ，则 context-&gt;outputFileName 赋值为 sdcard/log.txt； 5.2 注释② ：设置输出路径1234567891011121314151617static void setupOutputAndSchedulingPolicy( android_logcat_context_internal* context, bool blocking) { if (!context-&gt;outputFileName) return; ...... // 打开文件获得 fd context-&gt;output_fd = openLogFile(context-&gt;outputFileName); if (context-&gt;output_fd &lt; 0) { logcat_panic(context, HELP_FALSE, &quot;couldn't open output file&quot;); return; } ......} 5.3 注释③ ：写入日志12345678910while (...) { // 调用 liblog 库中的 android_logger_list_read 函数获取日志 int ret = android_logger_list_read(logger_list, &amp;log_msg); if (context-&gt;printBinary) { // 根据上面获取的文件 fd ,将日志消息写入文件 printBinary(context, &amp;log_msg); } else { processBuffer(context, dev, &amp;log_msg); } 以 printBinary() 函数为例： logcat.cpp # printBinary() : 12345void printBinary(android_logcat_context_internal* context, struct log_msg* buf) { size_t size = buf-&gt;len(); TEMP_FAILURE_RETRY(write(context-&gt;output_fd, buf, size));} 参考[ 1 ] Android物语：logcat[ 2 ] android调试——logcat详解[ 3 ] 玩转Android10源码开发定制(12)内核篇之logcat输出内核日志","link":"/2023/05/13/logcat/"},{"title":"mac config","text":"系统偏好设置 -&gt; 安全性与隐私 -&gt; 通用 -&gt; 选择“任何来源” 显示”任何来源”选项在控制台中执行： 1sudo spctl --master-disable 不显示”任何来源”选项在控制台中执行： 1sudo spctl --master-enable 如果选择了任何来源还是提示文件已损坏，命令行输入 1sudo xattr -r -d com.apple.quarantine 例如： 1sudo xattr -r -d com.apple.quarantine /Applications/WebStorm.app 如果不知道具体路径，可以打开应用程序窗口，然后拖拽软件的图片到命令行 就可以了","link":"/2022/09/19/mac-config/"},{"title":"mac git completion","text":"脚本 12mkdir -p ~/.zshcd ~/.zsh 1curl -o git-completion.bash https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash or 1curl -o git-completion.zsh https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.zsh 配置脚本(vim ~/.zshrc) 123zstyle ':completion:*:*:git:*' script ~/.zsh/git-completion.bashfpath=(~/.zsh $fpath)autoload -Uz compinit &amp;&amp; compinit 重启zsh终端 1rm ~/.zcompdump","link":"/2022/10/06/mac-git-completion/"},{"title":"pkg-config ffmpeg","text":"1export PKG_CONFIG_PATH=/home/dushicai/ffmpeg_build/lib/pkgconfig:PKG_CONFIG_PATH","link":"/2022/04/10/pkg-config-ffmpeg/"},{"title":"python3","text":"python -m http.server 8080启动http服务（prot:8080） python-is-python3使用python代替python3(创建python3的软连接)","link":"/2022/08/21/python3/"},{"title":"repo","text":"1repo sync -c -d -j8 --force-sync --force-remove-dirty","link":"/2023/05/12/repo/"},{"title":"terminal","text":"ctrl a移动到开头ctrl e移动到末尾ctrl b向前移动ctrl f向后移动ctrl w删除光标前一个单词ctrl delete删除光标后一个单词alt f向前移动一个单词alt b向后移动一个单词ctrl l清屏ctrl u剪切当前行（清除当前行输入）ctrl y粘贴","link":"/2023/05/12/terminal/"},{"title":"vim","text":"模式切换Esc插入转命令a i o命令转插入ctrl c | ctrl [退出命令模式gi快速切回上次编辑位置 插入模式a(append)光标后i(insert)光标前o(open new line)下一行A当前行尾部I当前行头部O上一行 命令模式e! 放弃修改，重新加载源文件 :set nu显示行号:set hls高亮:w保存:q退出:wq保存并退出/xxx查找xxxctrl h删除一个字符ctrl w删除一个单词ctrl u删除一行 跳转n下一个shift n上一个w/W移动到下个单词开头e移动到下个单词结尾b移动到上个单词开头h左移j下移k上移l右移f4查找当前行4字符(;,t移动)^行首$行尾g_非空白行尾gg移动到开头G移动到末尾ctrl o返回到上次光标位置ctrl u上翻页ctrl f下翻页H M L跳转到(当前屏幕的)上、中、下行zz把当前行放到terminal中间显示 删除x删除字符4x删除4个字符diw删除单词不包括空格daw(dw)删除单词包括空格dd删除整行2dd删除两行dt)删除本行直到)的字符d0 | d^删除行首到光标位置d$删除光标位置到行末 选中v选中字符V选中当前行 替换r替换s替换并进入insertct)删除到)并进入insert 查询/xx向前查询xx?xx向后查询xx**:% s/aaa/bbb/g全局把aaa替换成bbb**:1,6 s/aaa/bbb/g1-6行把aaa替换成bbb 查询 搜索","link":"/2023/05/12/vim/"},{"title":"wsl2-adb-bridge","text":"Windows: 12adb kill-serveradb -a -P 5037 nodaemon server WSL2: 123cat /etc/resolv.conf|grep nameserver|awk '{print $2}'export ADB_SERVER_SOCKET=tcp:$windows_host:5037export ADB_SERVER_SOCKET=tcp:192.168.31.38:5037","link":"/2022/04/10/wsl2-adb-bridge/"},{"title":"wsl2-disk","text":"Terminal: 123wsl -v -lwsl --shutdownGet-AppxPackage -Name &quot;*Ubuntu*&quot; | Select PackageFamilyName 资源管理器： 12%LOCALAPPDATA%%LOCALAPPDATA%\\Packages\\&lt;PackageFamilyName&gt;\\LocalState\\&lt;disk&gt;.vhdx 以管理员权限Terminal: 1234diskpartDISKPART&gt; Select vdisk file=&quot;&lt;pathToVHD&gt;&quot;DISKPART&gt; detail vdiskDISKPART&gt; EXPAND vdisk maximum=&lt;sizeInMegaBytes&gt; wsl-bash: 123sudo mount -t devtmpfs none /devmount | grep ext4sudo resize2fs /dev/sdb &lt;sizeInMegabytes&gt;M 可能需要安装 resize2fs 1sudo apt install resize2fs 1234resize2fs 1.44.1 (24-Mar-2021)Filesystem at /dev/sdb is mounted on /; on-line resizing requiredold_desc_blocks = 32, new_desc_blocks = 38The filesystem on /dev/sdb is now 78643200 (4k) blocks long.","link":"/2022/04/10/wsl2-disk/"},{"title":"wsl2-install","text":"wsl2 install Upgrade version from WSL 1 to WSL 2 wsl –set-version 2 Download the Linux kernel update package wsl_update_x64.msi","link":"/2022/08/21/wsl2-install/"},{"title":"wsl2","text":"ip addressip addr | grep eth0","link":"/2023/05/15/wsl2/"},{"title":"Linux","text":"快速删除文件 1rsync -a --delete emptyFolder deleteFolder java: No such file or directory 1apt-get install lib32z1 Java环境 12345export JAVA_HOME=/home/xxxx/app/jdk1.8.0_202export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATHsource ~/.bashrc Python环境 1sudo apt install python3 python3-pip -y Python虚拟环境 12345sudo apt install virtualenv virtualenvwrapper -yvim .bashrcexport WORKON__HOME=$HOME/.virtualenvssource /usr/share/virtualenvwrapper/virtualenvwrapper.shsource ~/.bashrc","link":"/2022/09/01/Linux/"},{"title":"mk bp","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151func init() { addStandardProperties(bpparser.StringType, map[string]string{ &quot;LOCAL_MODULE&quot;: &quot;name&quot;, &quot;LOCAL_CXX_STL&quot;: &quot;stl&quot;, &quot;LOCAL_MULTILIB&quot;: &quot;compile_multilib&quot;, &quot;LOCAL_ARM_MODE_HACK&quot;: &quot;instruction_set&quot;, &quot;LOCAL_SDK_VERSION&quot;: &quot;sdk_version&quot;, &quot;LOCAL_MIN_SDK_VERSION&quot;: &quot;min_sdk_version&quot;, &quot;LOCAL_NDK_STL_VARIANT&quot;: &quot;stl&quot;, &quot;LOCAL_JAR_MANIFEST&quot;: &quot;manifest&quot;, &quot;LOCAL_CERTIFICATE&quot;: &quot;certificate&quot;, &quot;LOCAL_PACKAGE_NAME&quot;: &quot;name&quot;, &quot;LOCAL_MODULE_RELATIVE_PATH&quot;: &quot;relative_install_path&quot;, &quot;LOCAL_PROTOC_OPTIMIZE_TYPE&quot;: &quot;proto.type&quot;, &quot;LOCAL_MODULE_OWNER&quot;: &quot;owner&quot;, &quot;LOCAL_RENDERSCRIPT_TARGET_API&quot;: &quot;renderscript.target_api&quot;, &quot;LOCAL_NOTICE_FILE&quot;: &quot;notice&quot;, &quot;LOCAL_JAVA_LANGUAGE_VERSION&quot;: &quot;java_version&quot;, &quot;LOCAL_INSTRUMENTATION_FOR&quot;: &quot;instrumentation_for&quot;, &quot;LOCAL_MANIFEST_FILE&quot;: &quot;manifest&quot;, &quot;LOCAL_DEX_PREOPT_PROFILE_CLASS_LISTING&quot;: &quot;dex_preopt.profile&quot;, &quot;LOCAL_TEST_CONFIG&quot;: &quot;test_config&quot;, }) addStandardProperties(bpparser.ListType, map[string]string{ &quot;LOCAL_SRC_FILES&quot;: &quot;srcs&quot;, &quot;LOCAL_SRC_FILES_EXCLUDE&quot;: &quot;exclude_srcs&quot;, &quot;LOCAL_HEADER_LIBRARIES&quot;: &quot;header_libs&quot;, &quot;LOCAL_SHARED_LIBRARIES&quot;: &quot;shared_libs&quot;, &quot;LOCAL_STATIC_LIBRARIES&quot;: &quot;static_libs&quot;, &quot;LOCAL_WHOLE_STATIC_LIBRARIES&quot;: &quot;whole_static_libs&quot;, &quot;LOCAL_SYSTEM_SHARED_LIBRARIES&quot;: &quot;system_shared_libs&quot;, &quot;LOCAL_ASFLAGS&quot;: &quot;asflags&quot;, &quot;LOCAL_CLANG_ASFLAGS&quot;: &quot;clang_asflags&quot;, &quot;LOCAL_CONLYFLAGS&quot;: &quot;conlyflags&quot;, &quot;LOCAL_CPPFLAGS&quot;: &quot;cppflags&quot;, &quot;LOCAL_REQUIRED_MODULES&quot;: &quot;required&quot;, &quot;LOCAL_OVERRIDES_MODULES&quot;: &quot;overrides&quot;, &quot;LOCAL_LDLIBS&quot;: &quot;host_ldlibs&quot;, &quot;LOCAL_CLANG_CFLAGS&quot;: &quot;clang_cflags&quot;, &quot;LOCAL_YACCFLAGS&quot;: &quot;yaccflags&quot;, &quot;LOCAL_SANITIZE_RECOVER&quot;: &quot;sanitize.recover&quot;, &quot;LOCAL_LOGTAGS_FILES&quot;: &quot;logtags&quot;, &quot;LOCAL_EXPORT_HEADER_LIBRARY_HEADERS&quot;: &quot;export_header_lib_headers&quot;, &quot;LOCAL_EXPORT_SHARED_LIBRARY_HEADERS&quot;: &quot;export_shared_lib_headers&quot;, &quot;LOCAL_EXPORT_STATIC_LIBRARY_HEADERS&quot;: &quot;export_static_lib_headers&quot;, &quot;LOCAL_INIT_RC&quot;: &quot;init_rc&quot;, &quot;LOCAL_VINTF_FRAGMENTS&quot;: &quot;vintf_fragments&quot;, &quot;LOCAL_TIDY_FLAGS&quot;: &quot;tidy_flags&quot;, // TODO: This is comma-separated, not space-separated &quot;LOCAL_TIDY_CHECKS&quot;: &quot;tidy_checks&quot;, &quot;LOCAL_RENDERSCRIPT_INCLUDES&quot;: &quot;renderscript.include_dirs&quot;, &quot;LOCAL_RENDERSCRIPT_FLAGS&quot;: &quot;renderscript.flags&quot;, &quot;LOCAL_JAVA_RESOURCE_DIRS&quot;: &quot;java_resource_dirs&quot;, &quot;LOCAL_JAVACFLAGS&quot;: &quot;javacflags&quot;, &quot;LOCAL_ERROR_PRONE_FLAGS&quot;: &quot;errorprone.javacflags&quot;, &quot;LOCAL_DX_FLAGS&quot;: &quot;dxflags&quot;, &quot;LOCAL_JAVA_LIBRARIES&quot;: &quot;libs&quot;, &quot;LOCAL_STATIC_JAVA_LIBRARIES&quot;: &quot;static_libs&quot;, &quot;LOCAL_JNI_SHARED_LIBRARIES&quot;: &quot;jni_libs&quot;, &quot;LOCAL_AAPT_FLAGS&quot;: &quot;aaptflags&quot;, &quot;LOCAL_PACKAGE_SPLITS&quot;: &quot;package_splits&quot;, &quot;LOCAL_COMPATIBILITY_SUITE&quot;: &quot;test_suites&quot;, &quot;LOCAL_OVERRIDES_PACKAGES&quot;: &quot;overrides&quot;, &quot;LOCAL_ANNOTATION_PROCESSORS&quot;: &quot;plugins&quot;, &quot;LOCAL_PROGUARD_FLAGS&quot;: &quot;optimize.proguard_flags&quot;, &quot;LOCAL_PROGUARD_FLAG_FILES&quot;: &quot;optimize.proguard_flags_files&quot;, // These will be rewritten to libs/static_libs by bpfix, after their presence is used to convert // java_library_static to android_library. &quot;LOCAL_SHARED_ANDROID_LIBRARIES&quot;: &quot;android_libs&quot;, &quot;LOCAL_STATIC_ANDROID_LIBRARIES&quot;: &quot;android_static_libs&quot;, &quot;LOCAL_ADDITIONAL_CERTIFICATES&quot;: &quot;additional_certificates&quot;, // Jacoco filters: &quot;LOCAL_JACK_COVERAGE_INCLUDE_FILTER&quot;: &quot;jacoco.include_filter&quot;, &quot;LOCAL_JACK_COVERAGE_EXCLUDE_FILTER&quot;: &quot;jacoco.exclude_filter&quot;, }) addStandardProperties(bpparser.BoolType, map[string]string{ // Bool properties &quot;LOCAL_IS_HOST_MODULE&quot;: &quot;host&quot;, &quot;LOCAL_CLANG&quot;: &quot;clang&quot;, &quot;LOCAL_FORCE_STATIC_EXECUTABLE&quot;: &quot;static_executable&quot;, &quot;LOCAL_NATIVE_COVERAGE&quot;: &quot;native_coverage&quot;, &quot;LOCAL_NO_CRT&quot;: &quot;nocrt&quot;, &quot;LOCAL_ALLOW_UNDEFINED_SYMBOLS&quot;: &quot;allow_undefined_symbols&quot;, &quot;LOCAL_RTTI_FLAG&quot;: &quot;rtti&quot;, &quot;LOCAL_NO_STANDARD_LIBRARIES&quot;: &quot;no_standard_libs&quot;, &quot;LOCAL_PACK_MODULE_RELOCATIONS&quot;: &quot;pack_relocations&quot;, &quot;LOCAL_TIDY&quot;: &quot;tidy&quot;, &quot;LOCAL_USE_CLANG_LLD&quot;: &quot;use_clang_lld&quot;, &quot;LOCAL_PROPRIETARY_MODULE&quot;: &quot;proprietary&quot;, &quot;LOCAL_VENDOR_MODULE&quot;: &quot;vendor&quot;, &quot;LOCAL_ODM_MODULE&quot;: &quot;device_specific&quot;, &quot;LOCAL_PRODUCT_MODULE&quot;: &quot;product_specific&quot;, &quot;LOCAL_PRODUCT_SERVICES_MODULE&quot;: &quot;product_services_specific&quot;, &quot;LOCAL_EXPORT_PACKAGE_RESOURCES&quot;: &quot;export_package_resources&quot;, &quot;LOCAL_PRIVILEGED_MODULE&quot;: &quot;privileged&quot;, &quot;LOCAL_AAPT_INCLUDE_ALL_RESOURCES&quot;: &quot;aapt_include_all_resources&quot;, &quot;LOCAL_USE_EMBEDDED_NATIVE_LIBS&quot;: &quot;use_embedded_native_libs&quot;, &quot;LOCAL_USE_EMBEDDED_DEX&quot;: &quot;use_embedded_dex&quot;, &quot;LOCAL_DEX_PREOPT&quot;: &quot;dex_preopt.enabled&quot;, &quot;LOCAL_DEX_PREOPT_APP_IMAGE&quot;: &quot;dex_preopt.app_image&quot;, &quot;LOCAL_DEX_PREOPT_GENERATE_PROFILE&quot;: &quot;dex_preopt.profile_guided&quot;, &quot;LOCAL_PRIVATE_PLATFORM_APIS&quot;: &quot;platform_apis&quot;, &quot;LOCAL_JETIFIER_ENABLED&quot;: &quot;jetifier&quot;, }) } var moduleTypes = map[string]string{ &quot;BUILD_SHARED_LIBRARY&quot;: &quot;cc_library_shared&quot;, &quot;BUILD_STATIC_LIBRARY&quot;: &quot;cc_library_static&quot;, &quot;BUILD_HOST_SHARED_LIBRARY&quot;: &quot;cc_library_host_shared&quot;, &quot;BUILD_HOST_STATIC_LIBRARY&quot;: &quot;cc_library_host_static&quot;, &quot;BUILD_HEADER_LIBRARY&quot;: &quot;cc_library_headers&quot;, &quot;BUILD_EXECUTABLE&quot;: &quot;cc_binary&quot;, &quot;BUILD_HOST_EXECUTABLE&quot;: &quot;cc_binary_host&quot;, &quot;BUILD_NATIVE_TEST&quot;: &quot;cc_test&quot;, &quot;BUILD_HOST_NATIVE_TEST&quot;: &quot;cc_test_host&quot;, &quot;BUILD_NATIVE_BENCHMARK&quot;: &quot;cc_benchmark&quot;, &quot;BUILD_HOST_NATIVE_BENCHMARK&quot;: &quot;cc_benchmark_host&quot;, &quot;BUILD_JAVA_LIBRARY&quot;: &quot;java_library_installable&quot;, // will be rewritten to java_library by bpfix &quot;BUILD_STATIC_JAVA_LIBRARY&quot;: &quot;java_library&quot;, &quot;BUILD_HOST_JAVA_LIBRARY&quot;: &quot;java_library_host&quot;, &quot;BUILD_HOST_DALVIK_JAVA_LIBRARY&quot;: &quot;java_library_host_dalvik&quot;, &quot;BUILD_PACKAGE&quot;: &quot;android_app&quot;, &quot;BUILD_CTS_EXECUTABLE&quot;: &quot;cc_binary&quot;, // will be further massaged by bpfix depending on the output path &quot;BUILD_CTS_SUPPORT_PACKAGE&quot;: &quot;cts_support_package&quot;, // will be rewritten to android_test by bpfix &quot;BUILD_CTS_PACKAGE&quot;: &quot;cts_package&quot;, // will be rewritten to android_test by bpfix &quot;BUILD_CTS_TARGET_JAVA_LIBRARY&quot;: &quot;cts_target_java_library&quot;, // will be rewritten to java_library by bpfix &quot;BUILD_CTS_HOST_JAVA_LIBRARY&quot;: &quot;cts_host_java_library&quot;, // will be rewritten to java_library_host by bpfix } var prebuiltTypes = map[string]string{ &quot;SHARED_LIBRARIES&quot;: &quot;cc_prebuilt_library_shared&quot;, &quot;STATIC_LIBRARIES&quot;: &quot;cc_prebuilt_library_static&quot;, &quot;EXECUTABLES&quot;: &quot;cc_prebuilt_binary&quot;, &quot;JAVA_LIBRARIES&quot;: &quot;java_import&quot;, &quot;ETC&quot;: &quot;prebuilt_etc&quot;, }","link":"/2023/05/12/mk-bp/"}],"tags":[],"categories":[],"pages":[]}